/***************************************************************************
    begin                : Thu Jan 22 2004
    copyright            : (C) 2004 - 2006 by Alper Akcan
    email                : distchx@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License as        *
 *   published by the Free Software Foundation; either version 2.1 of the  *
 *   License, or (at your option) any later version.                       *
 *                                                                         *
 ***************************************************************************/

#include "SDL_eos.h"

//static SDLKey sdl_eos_keymap[128];
static SDLKey sdl_eos_keymap[256];

void sdl_eos_atexit (BWindowType *window)
{
	if (sdl_eos_running) {
		while (sdl_eos_running_) {
			usleep(20000);
		}
		sdl_eos_running = 0;
		SDL_PrivateQuit();
	}
}

void sdl_eos_atevent (BWindowType *window, BEventType *event)
{
        int state = 0;
        int button = 0;
        
	if ((event->type & B_MOUSE_EVENT) &&
	    ((event->mouse->x >= window->surface->buf->x) &&
	     (event->mouse->x <= window->surface->buf->x + window->surface->buf->w) &&
	     (event->mouse->y >= window->surface->buf->y) &&
	     (event->mouse->y <= window->surface->buf->y + window->surface->buf->h))) {
		if (event->type & B_MOUSE_OVER) {
			if (event->type & B_MOUSE_HINT) {
				state = SDL_PRESSED;
			}
			SDL_PrivateMouseMotion(state, 0, event->mouse->x - window->surface->buf->x, event->mouse->y - window->surface->buf->y);
		} else if (event->type & (B_MOUSE_PRESSED | B_MOUSE_RELEASED | B_MOUSE_CLICKED)) {
			if (event->type & (B_MOUSE_PRESSED)) {
				state = SDL_PRESSED;
			}
			if (event->type & (B_MOUSE_RELEASED | B_MOUSE_CLICKED)) {
				state = SDL_RELEASED;
			}
			switch (event->mouse->b) {
				case B_MOUSE_RIGHTBUTTON:		button = SDL_BUTTON_RIGHT;	break;
				case B_MOUSE_MIDDLEBUTTON:	button = SDL_BUTTON_MIDDLE;	break;
				case B_MOUSE_LEFTBUTTON:		button = SDL_BUTTON_LEFT;	break;
				default:			button = 0;			break;
			}
			SDL_PrivateMouseButton(state, button, event->mouse->x - window->surface->buf->x, event->mouse->y - window->surface->buf->y);
		}
	}
	if (event->type & B_KEYBD_EVENT) {
		SDL_keysym keysym;
		if (event->type & B_KEYBD_PRESSED) {
			state = SDL_PRESSED;
		} else if (event->type & B_KEYBD_RELEASED) {
			state = SDL_RELEASED;
		}
		SDL_PrivateKeyboard(state, sdl_eos_translatekey(event, &keysym));
	}
}

void sdl_eos_PumpEvents(_THIS)
{
}

void sdl_eos_InitOSKeymap (_THIS)
{
	int i;
	
	for (i = 0; i < SDL_TABLESIZE(sdl_eos_keymap); i++) {
		sdl_eos_keymap[i] = SDLK_UNKNOWN;
	}
	
	sdl_eos_keymap[B_KEY_ESCAPE] = SDLK_ESCAPE;
	sdl_eos_keymap[B_KEY_ONE] = SDLK_1;
	sdl_eos_keymap[B_KEY_TWO] = SDLK_2;
	sdl_eos_keymap[B_KEY_THREE] = SDLK_3;
	sdl_eos_keymap[B_KEY_FOUR] = SDLK_4;
	sdl_eos_keymap[B_KEY_FIVE] = SDLK_5;
	sdl_eos_keymap[B_KEY_SIX] = SDLK_6;
	sdl_eos_keymap[B_KEY_SEVEN] = SDLK_7;
	sdl_eos_keymap[B_KEY_EIGHT] = SDLK_8;
	sdl_eos_keymap[B_KEY_NINE] = SDLK_9;
	sdl_eos_keymap[B_KEY_ZERO] = SDLK_0;
	sdl_eos_keymap[B_KEY_MINUS] = SDLK_MINUS;
	sdl_eos_keymap[B_KEY_EQUAL] = SDLK_EQUALS;
	sdl_eos_keymap[B_KEY_DELETE] = SDLK_BACKSPACE;
	sdl_eos_keymap[B_KEY_TAB] = SDLK_TAB;
	sdl_eos_keymap[B_KEY_q] = SDLK_q;
	sdl_eos_keymap[B_KEY_w] = SDLK_w;
	sdl_eos_keymap[B_KEY_e] = SDLK_e;
	sdl_eos_keymap[B_KEY_r] = SDLK_r;
	sdl_eos_keymap[B_KEY_t] = SDLK_t;
	sdl_eos_keymap[B_KEY_y] = SDLK_y;
	sdl_eos_keymap[B_KEY_u] = SDLK_u;
	sdl_eos_keymap[B_KEY_i] = SDLK_i;
	sdl_eos_keymap[B_KEY_o] = SDLK_o;
	sdl_eos_keymap[B_KEY_p] = SDLK_p;
	sdl_eos_keymap[B_KEY_BRACKETLEFT] = SDLK_LEFTBRACKET;
	sdl_eos_keymap[B_KEY_BRACKETRIGHT] = SDLK_RIGHTBRACKET;
	sdl_eos_keymap[B_KEY_RETURN] = SDLK_RETURN;
	sdl_eos_keymap[B_KEY_LEFTCONTROL] = SDLK_LCTRL;
	sdl_eos_keymap[B_KEY_a] = SDLK_a;
	sdl_eos_keymap[B_KEY_s] = SDLK_s;
	sdl_eos_keymap[B_KEY_d] = SDLK_d;
	sdl_eos_keymap[B_KEY_f] = SDLK_f;
	sdl_eos_keymap[B_KEY_g] = SDLK_g;
	sdl_eos_keymap[B_KEY_h] = SDLK_h;
	sdl_eos_keymap[B_KEY_j] = SDLK_j;
	sdl_eos_keymap[B_KEY_k] = SDLK_k;
	sdl_eos_keymap[B_KEY_l] = SDLK_l;
	sdl_eos_keymap[B_KEY_SEMICOLON] = SDLK_SEMICOLON;
	sdl_eos_keymap[B_KEY_APOSTROPHE] = SDLK_QUOTE;
	sdl_eos_keymap[B_KEY_GRAVE] = SDLK_BACKQUOTE;
	sdl_eos_keymap[B_KEY_LEFTSHIFT] = SDLK_LSHIFT;
	sdl_eos_keymap[B_KEY_BACKSLASH] = SDLK_BACKSLASH;
	sdl_eos_keymap[B_KEY_z] = SDLK_z;
	sdl_eos_keymap[B_KEY_x] = SDLK_x;
	sdl_eos_keymap[B_KEY_c] = SDLK_c;
	sdl_eos_keymap[B_KEY_v] = SDLK_v;
	sdl_eos_keymap[B_KEY_b] = SDLK_b;
	sdl_eos_keymap[B_KEY_n] = SDLK_n;
	sdl_eos_keymap[B_KEY_m] = SDLK_m;
	sdl_eos_keymap[B_KEY_COMMA] = SDLK_COMMA;
	sdl_eos_keymap[B_KEY_PERIOD] = SDLK_PERIOD;
	sdl_eos_keymap[B_KEY_SLASH] = SDLK_SLASH;
	sdl_eos_keymap[B_KEY_RIGHTSHIFT] = SDLK_RSHIFT;
	sdl_eos_keymap[B_KEY_KP_MULTIPLY] = SDLK_KP_MULTIPLY;
	sdl_eos_keymap[B_KEY_ALT] = SDLK_LALT;
	sdl_eos_keymap[B_KEY_SPACE] = SDLK_SPACE;
	sdl_eos_keymap[B_KEY_CAPS_LOCK] = SDLK_CAPSLOCK;
	sdl_eos_keymap[B_KEY_F1] = SDLK_F1;
	sdl_eos_keymap[B_KEY_F2] = SDLK_F2;
	sdl_eos_keymap[B_KEY_F3] = SDLK_F3;
	sdl_eos_keymap[B_KEY_F4] = SDLK_F4;
	sdl_eos_keymap[B_KEY_F5] = SDLK_F5;
	sdl_eos_keymap[B_KEY_F6] = SDLK_F6;
	sdl_eos_keymap[B_KEY_F7] = SDLK_F7;
	sdl_eos_keymap[B_KEY_F8] = SDLK_F8;
	sdl_eos_keymap[B_KEY_F9] = SDLK_F9;
	sdl_eos_keymap[B_KEY_F10] = SDLK_F10;
	sdl_eos_keymap[B_KEY_NUM_LOCK] = SDLK_NUMLOCK;
	sdl_eos_keymap[B_KEY_SCROLL_LOCK] = SDLK_SCROLLOCK;
	sdl_eos_keymap[B_KEY_KP_7] = SDLK_KP7;
	sdl_eos_keymap[B_KEY_KP_8] = SDLK_KP8;
	sdl_eos_keymap[B_KEY_KP_9] = SDLK_KP9;
	sdl_eos_keymap[B_KEY_KP_SUBTRACT] = SDLK_KP_MINUS;
	sdl_eos_keymap[B_KEY_KP_4] = SDLK_KP4;
	sdl_eos_keymap[B_KEY_KP_5] = SDLK_KP5;
	sdl_eos_keymap[B_KEY_KP_6] = SDLK_KP6;
	sdl_eos_keymap[B_KEY_KP_ADD] = SDLK_KP_PLUS;
	sdl_eos_keymap[B_KEY_KP_1] = SDLK_KP1;
	sdl_eos_keymap[B_KEY_KP_2] = SDLK_KP2;
	sdl_eos_keymap[B_KEY_KP_3] = SDLK_KP3;
	sdl_eos_keymap[B_KEY_KP_0] = SDLK_KP0;
	sdl_eos_keymap[B_KEY_KP_PERIOD] = SDLK_KP_PERIOD;
	sdl_eos_keymap[B_KEY_LESS] = SDLK_LESS;
	sdl_eos_keymap[B_KEY_F11] = SDLK_F11;
	sdl_eos_keymap[B_KEY_F12] = SDLK_F12;
	sdl_eos_keymap[B_KEY_KP_ENTER] = SDLK_KP_ENTER;
	sdl_eos_keymap[B_KEY_RIGHTCONTROL] = SDLK_RCTRL;
	sdl_eos_keymap[B_KEY_KP_DIVIDE] = SDLK_KP_DIVIDE;
	sdl_eos_keymap[B_KEY_VOIDSYMBOL] = SDLK_PRINT;
	sdl_eos_keymap[B_KEY_ALTGR] = SDLK_RALT;
	sdl_eos_keymap[B_KEY_BREAK] = SDLK_BREAK;
	sdl_eos_keymap[B_KEY_HOME] = SDLK_HOME;
	sdl_eos_keymap[B_KEY_UP] = SDLK_UP;
	sdl_eos_keymap[B_KEY_PAGEUP] = SDLK_PAGEUP;
	sdl_eos_keymap[B_KEY_LEFT] = SDLK_LEFT;
	sdl_eos_keymap[B_KEY_RIGHT] = SDLK_RIGHT;
	sdl_eos_keymap[B_KEY_END] = SDLK_END;
	sdl_eos_keymap[B_KEY_DOWN] = SDLK_DOWN;
	sdl_eos_keymap[B_KEY_PAGEDOWN] = SDLK_PAGEDOWN;
	sdl_eos_keymap[B_KEY_INSERT] = SDLK_INSERT;
	sdl_eos_keymap[B_KEY_REMOVE] = SDLK_DELETE;
	sdl_eos_keymap[B_KEY_PAUSE] = SDLK_PAUSE;
}

SDL_keysym * sdl_eos_translatekey(BEventType *event, SDL_keysym *keysym)
{
	keysym->scancode = event->keybd->scancode;
//	keysym->sym = (event->keybd->keycode == B_KEY_NOCODE) ? SDLK_UNKNOWN : sdl_eos_keymap[event->keybd->keycode];
	keysym->mod = KMOD_NONE;
	keysym->unicode = event->keybd->ascii;
	
//	if (SDL_TranslateUNICODE) {
//	}
	
	if (event->keybd->ascii > 0 && event->keybd->ascii < 128)
	  keysym->sym=event->keybd->ascii;
	else
	  keysym->sym=sdl_eos_keymap[event->keybd->scancode];

	return keysym;
}
